# -*- coding: utf-8 -*-
"""Extra_1_LP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cnCzvZr0eM3pCT2RdOTDgzFJCdJ_lEu_
"""

import random
import copy

def print_board(board):
    for row in board:
        print(" ".join(str(num) if num != 0 else '.' for num in row))
    print()

def compute_conflicts(board):
    conflicts = 0
    for i in range(9):
        row = [0]*10
        col = [0]*10
        for j in range(9):
            # Row conflicts
            if board[i][j] != 0:
                row[board[i][j]] += 1
            # Column conflicts
            if board[j][i] != 0:
                col[board[j][i]] += 1
        conflicts += sum(x-1 for x in row if x > 1)
        conflicts += sum(x-1 for x in col if x > 1)

    # Box conflicts
    for box_row in range(0, 9, 3):
        for box_col in range(0, 9, 3):
            box = [0]*10
            for i in range(3):
                for j in range(3):
                    val = board[box_row + i][box_col + j]
                    if val != 0:
                        box[val] += 1
            conflicts += sum(x-1 for x in box if x > 1)
    return conflicts

def get_possible_values(board, row, col):
    used = set()
    for i in range(9):
        used.add(board[row][i])
        used.add(board[i][col])
    box_row, box_col = row//3 * 3, col//3 * 3
    for i in range(3):
        for j in range(3):
            used.add(board[box_row+i][box_col+j])
    return [i for i in range(1, 10) if i not in used]

def initialize_board(board):
    filled = copy.deepcopy(board)
    for i in range(9):
        for j in range(9):
            if filled[i][j] == 0:
                options = get_possible_values(filled, i, j)
                if options:
                    filled[i][j] = random.choice(options)
                else:
                    filled[i][j] = random.randint(1, 9)
    return filled

def hill_climb(board):
    current = initialize_board(board)
    current_score = compute_conflicts(current)
    iterations = 0
    while True:
        improved = False
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    best_val = current[i][j]
                    best_score = current_score
                    for val in range(1, 10):
                        if val != current[i][j]:
                            temp = copy.deepcopy(current)
                            temp[i][j] = val
                            score = compute_conflicts(temp)
                            if score < best_score:
                                best_score = score
                                best_val = val
                                improved = True
                    current[i][j] = best_val
                    current_score = best_score
        iterations += 1
        if not improved or current_score == 0 or iterations > 1000:
            break
    return current, current_score

def menu():
    board = sample_board
    while True:
        print("Sudoku Solver - Hill Climbing Menu")
        print("1. Show Initial Board")
        print("2. Solve using Hill Climbing")
        print("3. Exit")
        choice = input("Enter your choice: ")
        if choice == "1":
            print("Initial Sudoku Board:")
            print_board(board)
        elif choice == "2":
            print("Solving...")
            solution, score = hill_climb(board)
            print("Solved Board (Final Conflicts: {})".format(score))
            print_board(solution)
        elif choice == "3":
            print("Exiting... Stay puzzlinâ€™ ðŸ‘‹")
            break
        else:
            print("Invalid choice, try again fam ðŸ’…")

# Start the menu
sample_board = [
    [5, 1, 7, 6, 0, 0, 0, 3, 4],
    [2, 8, 9, 0, 0, 4, 0, 0, 0],
    [3, 4, 6, 2, 0, 5, 0, 9, 0],
    [6, 0, 2, 0, 0, 0, 0, 1, 0],
    [0, 3, 8, 0, 0, 6, 0, 4, 7],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 9, 0, 0, 0, 0, 0, 7, 8],
    [7, 0, 3, 4, 0, 0, 5, 6, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
]
menu()

