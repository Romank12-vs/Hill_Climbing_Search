# -*- coding: utf-8 -*-
"""Extra_1_LP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cnCzvZr0eM3pCT2RdOTDgzFJCdJ_lEu_
"""

from flask import Flask, render_template, request
import copy, random

app = Flask(__name__)

# === SUDOKU LOGIC STARTS ===
def compute_conflicts(board):
    conflicts = 0
    for i in range(9):
        row = [0]*10
        col = [0]*10
        for j in range(9):
            if board[i][j] != 0:
                row[board[i][j]] += 1
            if board[j][i] != 0:
                col[board[j][i]] += 1
        conflicts += sum(x-1 for x in row if x > 1)
        conflicts += sum(x-1 for x in col if x > 1)
    for box_row in range(0, 9, 3):
        for box_col in range(0, 9, 3):
            box = [0]*10
            for i in range(3):
                for j in range(3):
                    val = board[box_row + i][box_col + j]
                    if val != 0:
                        box[val] += 1
            conflicts += sum(x-1 for x in box if x > 1)
    return conflicts

def get_possible_values(board, row, col):
    used = set()
    for i in range(9):
        used.add(board[row][i])
        used.add(board[i][col])
    box_row, box_col = row//3 * 3, col//3 * 3
    for i in range(3):
        for j in range(3):
            used.add(board[box_row+i][box_col+j])
    return [i for i in range(1, 10) if i not in used]

def initialize_board(board):
    filled = copy.deepcopy(board)
    for i in range(9):
        for j in range(9):
            if filled[i][j] == 0:
                options = get_possible_values(filled, i, j)
                filled[i][j] = random.choice(options) if options else random.randint(1, 9)
    return filled

def hill_climb(board):
    current = initialize_board(board)
    current_score = compute_conflicts(current)
    for _ in range(1000):
        improved = False
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    best_val = current[i][j]
                    best_score = current_score
                    for val in range(1, 10):
                        if val != current[i][j]:
                            temp = copy.deepcopy(current)
                            temp[i][j] = val
                            score = compute_conflicts(temp)
                            if score < best_score:
                                best_score = score
                                best_val = val
                                improved = True
                    current[i][j] = best_val
                    current_score = best_score
        if not improved or current_score == 0:
            break
    return current, current_score
# === SUDOKU LOGIC ENDS ===

@app.route("/", methods=["GET", "POST"])
def home():
    if request.method == "POST":
        # Convert form data to board
        board = []
        for i in range(9):
            row = []
            for j in range(9):
                cell = request.form.get(f"cell_{i}_{j}")
                row.append(int(cell) if cell and cell.isdigit() else 0)
            board.append(row)
        solved_board, conflicts = hill_climb(board)
        return render_template("index.html", board=solved_board, solved=True, conflicts=conflicts)
    return render_template("index.html", board=[[0]*9 for _ in range(9)], solved=False)

if __name__ == "__main__":
    app.run(debug=True)

